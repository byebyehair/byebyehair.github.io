<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:title" content="分布式锁之电商防超卖的N&#43;1个坑" />
    <title>分布式锁之电商防超卖的N&#43;1个坑 | 好事发生</title>
    <link rel="stylesheet" href="/css/style.css" /> 
    <link rel="stylesheet" href="/css/fonts.css" /> 
    <link rel="stylesheet" href="/css/syntax.css" />
    <link rel="icon" href="https://storage.hanyu.me/resource/img/icon/favicon.ico">
    <link rel="manifest" href="/site.webmanifest" />
    <link href="index.xml" type="application/atom+xml" rel="alternate" title="小韩好事发生">
    <link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/styles/default.min.css" type="text/css" rel="stylesheet" />
</head>
<body><body>
  <h1 class="site-title">好事发生</h1>
  <nav>
    <ul class="menu">
      
      <li><a class="no-tag" href="/">Posts</a></li>
      
      <li><a class="no-tag" href="/moment/">Moments</a></li>
      
      <li><a class="no-tag" href="/about/">About</a></li>
      
      <li><a class="no-tag" href="https://hanyu.me">Home</a></li>
      
    </ul>
    <hr />
  </nav>
</body>
<div id="content">
<div>
  <h1><span class="title">分布式锁之电商防超卖的N+1个坑</span></h1>
  <h4 class="date">
    <span class="lastmod">Last updated:</span> 2021/03/23
    &nbsp;&nbsp;&nbsp;
    <span class="initpost">Published at:</span> 2021/03/23
  </h4>
</div>


<main><p>大家好，我是Damon。<br>
今天和同事讨论库存防超卖问题，发现虽然只是简单的库存扣减场景，却隐藏着很多坑，一不小心就容易翻车，让我来填平这些坑。</p>
<h2 id="单实例环境">单实例环境</h2>
<p>一般电商体系防止库存超卖，主要有以下几种方式：</p>
<!--![导图](img/oversold.png)-->




    <a class="imgshow" data-fancybox="gallery" href="https://storage.hanyu.me/files/blog/tech/1/img/oversold.png?imageMogr2/rquality/70" data-caption="" style="text-align: center;">
    
        <img src="https://storage.hanyu.me/files/blog/tech/1/img/oversold.png?q=80" style="max-width: 100%;height: 100%;object-fit: cover;" />
         
    </a>

<p>防止库存超卖，最先想到的可能就是「锁」，如果是一些单实例部署的库存服务，大部分情况下我们可以使用以下锁或并发工具类：</p>
<!--![单机锁](img/java_lock.png)-->




    <a class="imgshow" data-fancybox="gallery" href="https://storage.hanyu.me/files/blog/tech/1/img/java_lock.png?imageMogr2/rquality/70" data-caption="" style="text-align: center;">
    
        <img src="https://storage.hanyu.me/files/blog/tech/1/img/java_lock.png?q=80" style="max-width: 100%;height: 100%;object-fit: cover;" />
         
    </a>

<p>这三个任何一个都可以保证同一单位时间只有一个线程能够进行库存扣减，废话不多说，上码！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 库存扣减（伪代码 ReentrantLock )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param stockRequestDTO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return Boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Boolean <span style="color:#a6e22e">stockHandle</span>(StockRequestDTO stockRequestDTO) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 日志打印...校验...前置处理等...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> stock <span style="color:#f92672">=</span> stockMapper.<span style="color:#a6e22e">getStock</span>(stockRequestDTO.<span style="color:#a6e22e">getGoodsId</span>());
</span></span><span style="display:flex;"><span>        reentrantLock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> stock <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">?</span> 
</span></span><span style="display:flex;"><span>                    stockMapper.<span style="color:#a6e22e">updateStock</span>(stockRequestDTO.<span style="color:#a6e22e">getGoodsId</span>(), <span style="color:#f92672">--</span>stock) : 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">?</span> <span style="color:#66d9ef">true</span> : <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (SQLException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 异常日志打印及处理...</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            reentrantLock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 库存扣减（伪代码 synchronized )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param stockRequestDTO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return Boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> Boolean <span style="color:#a6e22e">stockHandle</span>(StockRequestDTO stockRequestDTO){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 执行业务逻辑...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 库存扣减（伪代码 Semaphore )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param stockRequestDTO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return Boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Boolean <span style="color:#a6e22e">stockHandle</span>(StockRequestDTO stockRequestDTO) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>          semaphore.<span style="color:#a6e22e">acquire</span>();
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 执行业务逻辑...</span>
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>          semaphore.<span style="color:#a6e22e">release</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>如果你的项目是单实例部署，那么使用以上锁或并发工具中的一种，都可以有效的防止超卖出现。</p>
<h2 id="分布式环境">分布式环境</h2>
<p>但现在的互联网公司，基本都是负载均衡的方式，访问集群中多个实例的，所以基于JVM级别的锁无法发挥作用，需要引入第三方组件来解决，分布式锁登场。</p>
<p>如果想实现分布式环境下的锁机制，最简单的莫过于利用MySQL的锁机制:</p>
 <!-- ![DBLOCK](img/db_lock.png)-->

  
  
  
      <a class="imgshow" data-fancybox="gallery" href="https://storage.hanyu.me/files/blog/tech/1/img/db_lock.png?imageMogr2/rquality/70" data-caption="" style="text-align: center;">
      
          <img src="https://storage.hanyu.me/files/blog/tech/1/img/db_lock.png?q=80" style="max-width: 100%;height: 100%;object-fit: cover;" />
           
      </a>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#f92672">***</span> <span style="color:#960050;background-color:#1e0010">使用悲观锁实现</span> <span style="color:#f92672">***</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">begin</span>; <span style="color:#75715e">-- 开启事务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span>  stock_num <span style="color:#66d9ef">from</span> t_stock t_stock <span style="color:#66d9ef">where</span> goodsId <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;12345&#39;</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">update</span>; <span style="color:#75715e">-- 获取并设置排他锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t_stock <span style="color:#66d9ef">set</span> stock_num <span style="color:#f92672">=</span> stock_num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>  <span style="color:#66d9ef">where</span> goodsId <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;12345&#39;</span> <span style="color:#960050;background-color:#1e0010">；</span><span style="color:#75715e">-- 更新资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">commit</span>; <span style="color:#75715e">-- 提交事务并解锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">***</span> <span style="color:#960050;background-color:#1e0010">乐观锁实现</span> <span style="color:#f92672">***</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">update</span> t_stock <span style="color:#66d9ef">set</span> stock_num <span style="color:#f92672">=</span> stock_num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> , <span style="color:#66d9ef">version</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">version</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">where</span> goodsId <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;12345&#39;</span> <span style="color:#66d9ef">and</span> <span style="color:#66d9ef">version</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 1.更新资源时先判断当前数据版本号和之前获取时是否一致
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- 2.如果版本号一致，更新资源并版本号+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- 3.若版本号不一致，返回错误并由业务系统进行自旋重试
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">***</span> <span style="color:#960050;background-color:#1e0010">唯一索引实现</span> <span style="color:#f92672">***</span> 
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">较简单，此方式实际应用几乎没有，不再赘述</span>
</span></span></code></pre></div><p>有一点要注意，乐观锁的自旋是需要在自己的业务逻辑中实现的。</p>
<p>使用数据库作为分布式锁，优点是实现简单、不需要引入其他中间件，缺点是可能存在磁盘IO，性能一般。</p>
<p>那有没有性能够用、实现简单、且在分布式环境下能保证资源并发安全的方案呢？常规有三，Redis、Zookeeper、MQ，其中MQ的解决方案不能算分布式锁。<br>
今天我们介绍第一种，使用Redis实现分布式锁，Redis分布式锁的特点是轻松保证可重入、互斥。<br>
Redis中提供了SetNX+Expire两个命令，可以对指定的Key加锁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>// redis原生命令
</span></span><span style="display:flex;"><span>redis-cli 127.0.0.1:6379&gt; SETNX KEY_NAME VALUE
</span></span><span style="display:flex;"><span>redis-cli 127.0.0.1:6379&gt; EXPlRE &lt;key&gt; &lt;ttl&gt; 
</span></span></code></pre></div><p>spring-boot-starter-data-redis 也提供了操作Redis的模板类：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>     <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 库存扣减 (伪代码 spring-boot-starter-data-redis中提供的模板方法)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param stockRequestDTO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return Boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>(rollbackFor <span style="color:#f92672">=</span> {RuntimeException.<span style="color:#a6e22e">class</span>, Error.<span style="color:#a6e22e">class</span>})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Boolean <span style="color:#a6e22e">stockHandle</span>(StockRequestDTO stockRequestDTO) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 省略日志打印...校验...前置处理等...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            Boolean redisLock <span style="color:#f92672">=</span> redisTemplate
</span></span><span style="display:flex;"><span>                    .<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>                    .<span style="color:#a6e22e">setIfAbsent</span>(stockLockKey, <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (redisLock) {
</span></span><span style="display:flex;"><span>                redisTemplate.<span style="color:#a6e22e">expire</span>((stockLockKey,1,TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>                Object stock <span style="color:#f92672">=</span> redisTemplate
</span></span><span style="display:flex;"><span>                        .<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>                        .<span style="color:#a6e22e">get</span>(stockKeyPrefix.<span style="color:#a6e22e">concat</span>(stockRequestDTO.<span style="color:#a6e22e">getGoodsId</span>()));
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> stock <span style="color:#f92672">||</span> Integer.<span style="color:#a6e22e">parseInt</span>(stock.<span style="color:#a6e22e">toString</span>()) <span style="color:#f92672">&lt;=</span> 0) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 库存异常</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 扣减库存</span>
</span></span><span style="display:flex;"><span>                    stock <span style="color:#f92672">=</span> Integer.<span style="color:#a6e22e">parseInt</span>(stock.<span style="color:#a6e22e">toString</span>()) <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 更新数据库、缓存等...</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 释放锁等等后置处理...</span>
</span></span><span style="display:flex;"><span>            redisTemplate.<span style="color:#a6e22e">delete</span>(stockLockKey);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><blockquote>
<p>原子性问题</p>
</blockquote>
<p>以上代码存在一个问题，假设</p>
<ul>
<li>1.）A线程获取锁成功</li>
<li>2.）A线程所在实例挂掉了</li>
<li>3.）A线程还没来得及给锁设置过期时间，Redis中资源会被永久锁住</li>
</ul>
<p>所以我们需要使用原子指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>// redis原生命令
</span></span><span style="display:flex;"><span>redis-cli 127.0.0.1:6379&gt; set key value <span style="color:#f92672">[</span>EX seconds<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>PX milliseconds<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>NX|XX<span style="color:#f92672">]</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 方式一：省略其他代码......</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span> redisLock <span style="color:#f92672">=</span> redisTemplate
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">setIfAbsent</span>(stockLockKey,<span style="color:#66d9ef">true</span>,30, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#75715e">// 方式二：使用Lua脚本进行加锁保证原子性（伪代码）</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> {
</span></span><span style="display:flex;"><span>        StringBuilder sb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;if redis.call(\&#34;setnx\&#34;, KEYS[1], KEYS[2]) == 1 then&#34;</span>);
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;return redis.call(\&#34;pexpire\&#34;, KEYS[1], KEYS[3])&#34;</span>);
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;else&#34;</span>);
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;return 0&#34;</span>);
</span></span><span style="display:flex;"><span>        LUA_SCRIPT <span style="color:#f92672">=</span> sb.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Long <span style="color:#a6e22e">redisLockByLua</span>(String key, <span style="color:#66d9ef">int</span> num) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 脚本里的KEYS参数，忽略类型转换等......</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        keys.<span style="color:#a6e22e">add</span>(stockLockKey);
</span></span><span style="display:flex;"><span>        keys.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>        keys.<span style="color:#a6e22e">add</span>(30);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">long</span>) redisTemplate.<span style="color:#a6e22e">execute</span>(<span style="color:#66d9ef">new</span> DefaultRedisScript(LUA_SCRIPT), keys);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><blockquote>
<p>超时&amp;误删锁问题</p>
</blockquote>
<p>虽然我们优化了，但还是有BUG，假设现在A 和 B 两个线程同时访问以上代码：</p>
<ul>
<li>1.）A先获得锁</li>
<li>2.）A执行扣减库存过程中因为不可控的原因超过了设定的10秒，此时分布式锁失效</li>
<li>3.）B线程将竞争获得锁开始执行任务</li>
<li>4.）此时A和B并行对加锁资源操作，可能造成错误</li>
<li>5.）A执行比B执行任务快，A恰好执行到最后一步删除锁</li>
<li>6.）B的任务还在执行，B的锁却被A删除，C线程也将竞争到锁，与B同时并行执行，循环往复，业务语义发生错误，可能导致各种脏数据产生</li>
</ul>
<p>这种现象还是比较容易发生的，对于锁超时问题，我们加以优化：</p>
<ul>
<li>1.）假如锁的超时时间是10秒</li>
<li>2.）获取锁后使用ScheduledExecutorService开启守护线程</li>
<li>3.）守护线程每隔5秒去查看分布式锁是否还存在，如果存在就进行续期10秒</li>
</ul>
<p>对于误删锁的问题，我们也可以加强优化一下：</p>
<ul>
<li>1.）A线程获取到锁之前先生成一个随机串</li>
<li>2.）A线程将锁的value设置为该随机串</li>
<li>3.）A线程删除锁时先判断锁的value是否为A线程刚才随机生成的随机串</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 库存扣减 (伪代码 spring-boot-starter-data-redis中提供的模板方法)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param stockRequestDTO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return Boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>(rollbackFor <span style="color:#f92672">=</span> {RuntimeException.<span style="color:#a6e22e">class</span>, Error.<span style="color:#a6e22e">class</span>})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Boolean <span style="color:#a6e22e">stockHandle</span>(StockRequestDTO stockRequestDTO) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 省略日志打印...校验...前置处理等...</span>
</span></span><span style="display:flex;"><span>        String nonceStr <span style="color:#f92672">=</span> UUID.<span style="color:#a6e22e">randomUUID</span>().<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>        ScheduledExecutorService scheduledExecutorService <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newScheduledThreadPool</span>(1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//竞争锁</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">boolean</span> redisLock <span style="color:#f92672">=</span> redisTemplate
</span></span><span style="display:flex;"><span>                    .<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>                    .<span style="color:#a6e22e">setIfAbsent</span>(stockLockKey, <span style="color:#66d9ef">true</span>, 30, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (redisLock) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 开启守护线程定时对锁续命</span>
</span></span><span style="display:flex;"><span>                scheduledExecutorService.<span style="color:#a6e22e">scheduleWithFixedDelay</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (redisTemplate.<span style="color:#a6e22e">hasKey</span>(stockLockKey)) {
</span></span><span style="display:flex;"><span>                        redisTemplate.<span style="color:#a6e22e">expire</span>(stockLockKey, 30, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }, 15, 15, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 获取库存</span>
</span></span><span style="display:flex;"><span>                String stockKey <span style="color:#f92672">=</span>  stockKeyPrefix.<span style="color:#a6e22e">concat</span>(stockRequestDTO.<span style="color:#a6e22e">getGoodsId</span>());
</span></span><span style="display:flex;"><span>                Object stock <span style="color:#f92672">=</span> redisTemplate
</span></span><span style="display:flex;"><span>                        .<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>                        .<span style="color:#a6e22e">get</span>(stockKey);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> stock <span style="color:#f92672">||</span> Integer.<span style="color:#a6e22e">parseInt</span>(stock.<span style="color:#a6e22e">toString</span>()) <span style="color:#f92672">&lt;=</span> 0) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 库存异常</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 扣减库存</span>
</span></span><span style="display:flex;"><span>                    redisTemplate.<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>                            .<span style="color:#a6e22e">set</span>(stockKey,Integer.<span style="color:#a6e22e">parseInt</span>(stock.<span style="color:#a6e22e">toString</span>()) <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 更新数据库等...</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 释放锁等等后置处理... 也可使用lua脚本保证原子性判断和删除锁</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (redisTemplate.<span style="color:#a6e22e">opsForValue</span>().<span style="color:#a6e22e">get</span>(stockLockKey).<span style="color:#a6e22e">equals</span>(nonceStr)) {
</span></span><span style="display:flex;"><span>                redisTemplate.<span style="color:#a6e22e">delete</span>(stockLockKey);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            scheduledExecutorService.<span style="color:#a6e22e">shutdownNow</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>释放锁也需要原子性执行，我们依然使用Lua脚本来保证原子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#75715e">// 解锁 (伪代码)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> {
</span></span><span style="display:flex;"><span>        StringBuilder sb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;if redis.call(\&#34;get\&#34;,KEYS[1]) == KEYS[2] then&#34;</span>);
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;return redis.call(\&#34;del\&#34;,KEYS[1])&#34;</span>);
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;else&#34;</span>);
</span></span><span style="display:flex;"><span>        sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;return -1&#34;</span>);
</span></span><span style="display:flex;"><span>        LUA_SCRIPT <span style="color:#f92672">=</span> sb.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Long <span style="color:#a6e22e">redisUnlockByLua</span>(String key, <span style="color:#66d9ef">int</span> num) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 脚本里的KEYS参数，忽略类型转换等...</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        keys.<span style="color:#a6e22e">add</span>(stockLockKey);
</span></span><span style="display:flex;"><span>        keys.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;线程加锁时生成的随机数&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">long</span>) redisTemplate.<span style="color:#a6e22e">execute</span>(<span style="color:#66d9ef">new</span> DefaultRedisScript(LUA_SCRIPT), keys);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><blockquote>
<p>Redisson</p>
</blockquote>
<p>对于锁超时问题，我们还可以使用现成的工具Redisson，Redisson提供了WatchDog（看门狗）机制，内置了锁续命机制，无需手动实现。</p>
<!--![DBLOCK](img/redisson.png)-->

  
  
  
      <a class="imgshow" data-fancybox="gallery" href="https://storage.hanyu.me/files/blog/tech/1/img/redisson.png?imageMogr2/rquality/70" data-caption="" style="text-align: center;">
      
          <img src="https://storage.hanyu.me/files/blog/tech/1/img/redisson.png?q=80" style="max-width: 100%;height: 100%;object-fit: cover;" />
           
      </a>

<p>注意，要想使用开门狗机制Redisson加锁时不要指定超时时间，默认锁超时时间30秒，看门狗每隔30秒的1/3时间也就是10秒去检查一次锁状态，锁还在就进行续命。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 构造Redisson Config</span>
</span></span><span style="display:flex;"><span>Config config <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Config();
</span></span><span style="display:flex;"><span>config.<span style="color:#a6e22e">useClusterServers</span>().<span style="color:#a6e22e">addNodeAddress</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;redis://ip1:port1&#34;</span>,<span style="color:#e6db74">&#34;redis://ip2:port2&#34;</span>, <span style="color:#e6db74">&#34;redis://ip3:port3&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;redis://ip4:port4&#34;</span>,<span style="color:#e6db74">&#34;redis://ip5:port5&#34;</span>, <span style="color:#e6db74">&#34;redis://ip6:port6&#34;</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">setPassword</span>(<span style="color:#e6db74">&#34;a123456&#34;</span>).<span style="color:#a6e22e">setScanInterval</span>(5000);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 构造RedissonClient</span>
</span></span><span style="display:flex;"><span>RedissonClient redissonClient <span style="color:#f92672">=</span> Redisson.<span style="color:#a6e22e">create</span>(config);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置锁定资源名称</span>
</span></span><span style="display:flex;"><span>RLock rLock <span style="color:#f92672">=</span> redissonClient.<span style="color:#a6e22e">getLock</span>(<span style="color:#e6db74">&#34;lock_key&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// boolean isLock;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尝试获取分布式锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// isLock = rLock.tryLock(500, 15000, TimeUnit.MILLISECONDS);</span>
</span></span><span style="display:flex;"><span>    rLock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 日志...业务处理等...</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 日志等...</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 解锁</span>
</span></span><span style="display:flex;"><span>    rLock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>主从数据一致性问题</p>
</blockquote>
<p>不过此时还可能出现一种意外情况，假设Redis主从环境：</p>
<ul>
<li>
<p>1.）A线程在Redis Master节点获得了锁，还没同步给Slave</p>
</li>
<li>
<p>2.）Master节点挂掉</p>
</li>
<li>
<p>3.）故障转移后Slave节点升级为Master节点</p>
</li>
<li>
<p>4.）此时B线程将竞争到锁，至此A和B同时对加锁任务并行执行，业务语义发生错误，可能导致各种脏数据产生</p>
<p>要解决这个问题，可以使用Redis官方提供的RedLock算法。<br>
简单来说RedLock 的思想是使用多台Redis Master，节点完全独立，节点间不需要进行数据同步。<br>
假设N个节点，在有效时间内当获得锁的数量大于 (N/2+1) 代表成功，失败后需要向所有节点发送释放锁的消息。<br>
RedLock的方式也有缺点，因为需要对多个节点操作加锁解锁，高并发情况下，耗时较长响应延迟，对性能有影响。<br>
后面我们找个时间专门讲一下RedLock源码以及存在的问题。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Config config1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Config();
</span></span><span style="display:flex;"><span>config1.<span style="color:#a6e22e">useSingleServer</span>().<span style="color:#a6e22e">setAddress</span>(<span style="color:#e6db74">&#34;redis://ip1:port1&#34;</span>).<span style="color:#a6e22e">setPassword</span>(<span style="color:#e6db74">&#34;...&#34;</span>).<span style="color:#a6e22e">setDatabase</span>(0);
</span></span><span style="display:flex;"><span>RedissonClient redissonClient1 <span style="color:#f92672">=</span> Redisson.<span style="color:#a6e22e">create</span>(config1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Config config2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Config();
</span></span><span style="display:flex;"><span>config2.<span style="color:#a6e22e">useSingleServer</span>().<span style="color:#a6e22e">setAddress</span>(<span style="color:#e6db74">&#34;redis://ip2:port2&#34;</span>).<span style="color:#a6e22e">setPassword</span>(<span style="color:#e6db74">&#34;...&#34;</span>).<span style="color:#a6e22e">setDatabase</span>(0);
</span></span><span style="display:flex;"><span>RedissonClient redissonClient2 <span style="color:#f92672">=</span> Redisson.<span style="color:#a6e22e">create</span>(config2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Config config3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Config();
</span></span><span style="display:flex;"><span>config3.<span style="color:#a6e22e">useSingleServer</span>().<span style="color:#a6e22e">setAddress</span>(<span style="color:#e6db74">&#34;redis://ip3:port3&#34;</span>).<span style="color:#a6e22e">setPassword</span>(<span style="color:#e6db74">&#34;...&#34;</span>).<span style="color:#a6e22e">setDatabase</span>(0);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>RedissonClient redissonClient3 <span style="color:#f92672">=</span> Redisson.<span style="color:#a6e22e">create</span>(config3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String lockKey <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;lock_key&#34;</span>;
</span></span><span style="display:flex;"><span>RedissonRedLock redLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RedissonRedLock(
</span></span><span style="display:flex;"><span>                redissonClient1.<span style="color:#a6e22e">getLock</span>(lockKey), 
</span></span><span style="display:flex;"><span>                redissonClient2.<span style="color:#a6e22e">getLock</span>(lockKey), 
</span></span><span style="display:flex;"><span>                redissonClient3.<span style="color:#a6e22e">getLock</span>(lockKey)
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span><span style="color:#75715e">// boolean isLock;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尝试获取分布式锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// isLock = redLock.tryLock(500, 15000, TimeUnit.MILLISECONDS);</span>
</span></span><span style="display:flex;"><span>    redLock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 日志...业务处理等...</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 日志等...</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 解锁</span>
</span></span><span style="display:flex;"><span>    redLock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>事务问题</p>
</blockquote>
<p>至此，是不是万无一失了呢？其实还没完，还有一个隐藏问题。<br>
我们知道，MySQL默认的事务隔离级别是Repeatable-Read可重复读。</p>
<!--![DBLOCK](img/mysql_t.png)-->

  
  
  
      <a class="imgshow" data-fancybox="gallery" href="https://storage.hanyu.me/files/blog/tech/1/img/mysql_t.png?imageMogr2/rquality/70" data-caption="" style="text-align: center;">
      
          <img src="https://storage.hanyu.me/files/blog/tech/1/img/mysql_t.png?q=80" style="max-width: 100%;height: 100%;object-fit: cover;" />
           
      </a>

<p>通过上述表格可以看出，Repeatable-Read这种隔离级别在同一个事务中多次读取的数据是一致的； <br>
另一方面，Spring声明式事务默认的传播特性是Required，在调用声明式事务修饰的方法stockHandle之前就已经开启了事务；</p>
<p>以上两点会导致：</p>
<ul>
<li>
<p>1.）线程Thread-A和Thread-B都执行到该方法</p>
</li>
<li>
<p>2.）各自开启了事务Transation-A和Transation-B</p>
</li>
<li>
<p>3.）Transation-A先执行加锁、执行、解锁</p>
</li>
<li>
<p>4.）Transation-B后执行加锁、执行、解锁</p>
</li>
<li>
<p>5.）由于Transation-B事务的开启，是在Transation-A事务提交之前</p>
</li>
<li>
<p>6.）此时默认隔离级别Repeatable-Read，事务Transation-B事务读取不到Transation-A已经提交的数据</p>
</li>
<li>
<p>7.）就会出现Transation-A和Transation-B事务开启后读取到的值是一样的，即Transation-B读取的是Transation-A更新前的数据</p>
<p>要解决这种隐藏BUG，可以将库存信息放入Redis，利用Redis的decr方法在分布式环境下原子性的扣减库存：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>  <span style="color:#75715e">// 省略其他代码</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Redis原子扣减库存</span>
</span></span><span style="display:flex;"><span>   Long stock <span style="color:#f92672">=</span> redisTemplate.<span style="color:#a6e22e">opsForValue</span>().<span style="color:#a6e22e">decrement</span>(1);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> stock <span style="color:#f92672">||</span> Integer.<span style="color:#a6e22e">parseInt</span>(stock.<span style="color:#a6e22e">toString</span>()) <span style="color:#f92672">&lt;</span> 0){
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 库存异常</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 更新数据库等...</span>
</span></span></code></pre></div><p>至于MQ和Zookeeper方式今天不在此介绍啦，大家感兴趣的话我后面专门开篇来讲。<br>
其实没有最完美无缺的方案，以上方案还是会存在某些特定场景下的特定问题，具体场景具体分析，逐步优化，一步步思考，加固项目城墙之余，也夯实自身的技术壁垒。</p>
<blockquote>
<p>辛苦移步微信公众号点赞、在看、关注：
<a href="https://mp.weixin.qq.com/s/82S1AbBeJzYuGhl6FvjQcg">Redis系列 | 分布式锁-电商防超卖的N+1个坑！</a></p>
</blockquote>
</main>

<div class="discussion">
  <script src="https://giscus.app/client.js" data-repo="okhanyu/tech-blog" data-repo-id="R_kgDOMINapQ"
    data-category="Announcements" data-category-id="DIC_kwDOMINapc4CgBlL" data-mapping="pathname"
    data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light_high_contrast"
    data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script>
</div>

<script src=https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js>
</script>

<link href=https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css
rel=stylesheet>
<script src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.js>
</script>

<style type="text/css">
  .compensate-for-scrollbar{margin:auto;}
</style>
<script type="text/javascript">


     
$(document).ready((function (_this) {
     $('[data-fancybox="gallery"]').fancybox();
$(".fancybox").fancybox();

  return function () {
    let bt
    bt = $('#back_to_top')
    if ($(document).width() > 480) {
      $(window).scroll(function () {
        let st
        st = $(window).scrollTop()
        if (st > 30) {
          return bt.css('display', 'block')
        } else {
          return bt.css('display', 'none')
        }
      })
      return bt.click(function () {
        $('body,html').animate({
          scrollTop: 0,
        }, 800)
        return false
      })
    }
  }
})(this));



</script>
</div><footer>
  <hr />
  <small
    >Copyright 2021-2024
        <a href="https://github.com/okhanyu" target="_blank">Damon</a><span>
    All articles on this site are licensed under a
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a >
  </small>
</footer>
</body>
</html>
