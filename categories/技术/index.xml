<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on 好事发生</title>
    <link>https://blog.hanyu.me/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on 好事发生</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 04 Jul 2024 17:51:21 +0800</lastBuildDate>
    <atom:link href="https://blog.hanyu.me/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>要使用业务唯一ID做主键吗？</title>
      <link>https://blog.hanyu.me/tech/4/</link>
      <pubDate>Thu, 04 Jul 2024 17:51:21 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/4/</guid>
      <description>注意：&#xA;本篇文章需阅读者掌握MySQL索引基本原理，可提前阅读 MySQL系列 | 浅尝MySQL索引 本篇文章涉及的V2帖子，没有特殊能力者，是访问不通的 本人无特殊能力去看V2帖子，是不小心在某个地方看到，已全然忘记出处，是一位遵纪守法的好公民 看到V2一篇帖子中的提问：https://go.lion.im/sk7qf ，促使我写下了这篇文章。&#xA;这位楼主的问题看似简单，但挺值得思考的。&#xA;这个问题我曾经想当然的认为，答案就应该是“需要使用自增ID列作为主键”，直到曾经一次滴滴的面试，被问到几乎同样的问题，才进行了深度的思考。&#xA;很多时候我们在设计数据库表的时候，明明已经有了一个逻辑上的唯一ID，却依然新建了一个自增的ID作为物理主键，在业务上却毫无用处，仿佛就像人要吃饭睡觉一样自然，why?&#xA;非自增主键会产生的问题 我们先来看看，为什么我们需要一个自增的主键？&#xA;性能问题 MySQL InnoDB 引擎的主键索引是一棵B+树结构，为了维护索引数据的有序性，会对新增数据进行比较，如果大于最大值，则只需要在最后记录后面插入一个新记录，如果小于，那么会去查找应该插入的具体位置。&#xA;页分裂 由于数据页的大小默认是16KB，如果恰巧要插入数据的数据页已满，就需要在此位置申请一个新的数据页，然后迁移部分数据过去，这个过程称为页分裂。&#xA;所以，如果我们的主键是自增的，那么每次新增数据，都会直接在最大记录后插入，非常高效。&#xA;空间问题 页空洞 如果主键是非自增的，除了要在插入过程中，经过多次比较、页分裂导致数据挪动等额外的耗时操作外，还会产生页空洞，致使空间利用率下降。&#xA;辅助索引 当我们为了高效多维度查询，对一张表创建了多个辅助索引时，辅助索引的叶子节点存储的是主键值。&#xA;如果我们使用业务上的唯一ID来做主键，由于一般业务上的唯一ID为了保证唯一性，生成的ID可能较长，那么所有辅助索引的叶子节点数据都会变大。 例如，用18位身份证号做主键，刨除其他额外信息，需要18个字节，而如果使用整型自增，则只需要4字节。&#xA;综上来看，无论是从性能上，还是空间占用上，我们确实应该使用自增ID列做主键，而不应该使用业务唯一ID来做主键。&#xA;那么，所有场景都该如此吗？不，当然不是。&#xA;业务唯一ID适合作为主键的场景 什么场景下，我们可以使用业务唯一ID来做主键呢？&#xA;有限场景一 业务唯一ID必须是自增趋势的 只会有一个主键索引 如果同时满足以上两点，那么使用业务唯一ID作为主键是最佳的。&#xA;因为如果此时，再去建立自增ID列，那么必然要基于业务唯一ID建立辅助索引，我们知道，由于自增ID是不会在业务中被使用的，所以我们的查询，都要基于业务唯一ID来进行，这样将会在每次查询时，造成回表。&#xA;所以，使用业务唯一ID作为主键既避免了回表操作，又保证了主键的递增趋势，也不需要创建辅助索引，一举三得。&#xA;有限场景二 读多写少 数据量小 假设你的业务唯一ID不是自增趋势，是否可以使用它做主键呢？&#xA;答案是可以。&#xA;但要满足以上两个条件，第一是，这张表，必须是读多写少的，例如我曾在一家在线教育公司任职，课程产品表，就是一个读多写极少，且数据量很小的表，即使课程唯一ID无序，也完全可以作为主键，对性能几乎无影响，新增频率极低。&#xA;总结 其实当我们的软硬件资源足够充沛，并可预见的能持续保持时，我们可以减少一些开发、设计细节上的斟酌和处理，但是，思考却不能敷衍。&#xA;不同的外部条件下，我们的行为可能会做出调整或取舍，但思考必须是细致的、全面的、尽力的，为作品，也为自己的成长。&#xA;个人博客：HanYu.me&#xA;技术网站：404.site&#xA;公众号： 今天404</description>
    </item>
    <item>
      <title>高并发短链系统设计</title>
      <link>https://blog.hanyu.me/tech/3/</link>
      <pubDate>Thu, 04 May 2023 10:01:22 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/3/</guid>
      <description>原则与底线：不说废话、不凑字数、不标题党。&#xA;注：本文均为韩宇的胡思乱写，你随便抄&#xA;背景 什么是短链 一个长的网址链接，转换为一个短的网址链接。&#xA;比如我发微博内容带有 https://blog.hanyu.cool/about/ 链接时，链接会自动转换成 https://t.cn/A6NlWmYi 这样的短网址。&#xA;微博的短网址域名为：t.cn，腾讯的短网址域名为 url.cn，阅读本文后，就可以自己实现一个高性能短链服务。&#xA;短链的作用 缩减无意义的地址长度，多出空间给实际内容（当前微博限制5000个字） 对URL进行流控、点击统计，来源识别等，方便进行数据分析 防止直接暴露参数等信息，防止某些平台对参数中的关键词屏蔽 方便对URL进行封禁，相同URL通过生成转换之后，最终地址是相同的 原理与实现 核心原理 生成&amp;amp;转换 存储 映射 实现过程 用户先访问短网址，短网址将自动请求至短链服务器 短链服务器收到请求后，在映射中通过短网址查找原始长链 服务端将原始长链以302或301状态码返回给用户 用户浏览器收到后重定向到原始长链 生成短链主要有两种方式，哈希和ID生成器。&#xA;哈希 哈希算法 哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值，所以可以利用哈希算法，来生成短网址。&#xA;常用的哈希算法如MD5、SHA、MurMurHash、CRC32等。&#xA;短链不需要考虑反向解密难度，只需要考虑计算速度快、冲突概率小即可。&#xA;目前应用比较广泛非加密算法是2008 年被发明的MurmurHash，据资料显示，现在已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene等软件中，MurmurHash算法具体实现可自行去了解，此处不展开（因为我懂得不多）。&#xA;MurmurHash 计算可选长度128位、32位等，位数多碰撞的概率就小，如果短链系统用的人不多，可以选择32位，这样生成的短链更短。&#xA;短链服务端接收到生成的请求后，可以把长链做 MurmurHash 计算，可以得到的一个哈希值，将哈希值与短链域名拼接，即可得到完整短链，如： t.cn/111111111&#xA;进制转换 如上所示，MurmurHash计算后得到的结果并不算短，我们可以优化一下，常用的方式是将10进制转换成62进制。 10进制转换62进制的逻辑就是，一直循环用62取余然后倒序：&#xA;最终 t.cn/111111111 用62进制表示的短链就是 t.cn/7WD4h 。&#xA;假设生成6位字符的短链： 10进制 最大只能生成 10 ^ 6 - 1 = 999999个 16进制 最大只能生成 16 ^ 6 - 1 = 16777215个 62进制 最大竟能生成 62 ^ 6 - 1 = 56800235583个 A-Z a-z 0-9 刚好等于62位。</description>
    </item>
    <item>
      <title>浅尝MySQL索引</title>
      <link>https://blog.hanyu.me/tech/2/</link>
      <pubDate>Wed, 09 Feb 2022 17:28:32 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/2/</guid>
      <description>写在前面的废话 Hello，大家好，我是Damon，一年前我写了一篇文章，然后拖更至今。 这其中有自己懒惰、工作变动等因素，年前这段时间一直在求职面试，拿到了些一线大厂和一些独角兽的offer。这段时间面试的经验和学习的过程对我自己帮助很大，面经还在整理中，后续会发出来给大家做一个参考吧。&#xA;因为每家公司的面试官不同，出题也是千遍万化，所以有些基础的核心知识，必须要体系化的学习，今天写这篇MySQL索引相关的知识也都是面试必问，后面我也会把一些锁、事务等等相关知识点写出来。&#xA;从今天开始，也会持续更新啦。虽然这篇文章很八股很基础，但总要一点点来，不积跬步无以至千里。如果觉得西瓜不错，可以点击关注哦。&#xA;咱们一起成长吧！&#xA;什么是索引 索引是一种有序的数据结构，它的作用很多人形象的比喻为书的目录。&#xA;注：数据结构一般是指逻辑上数据的组织形式，就好像运动会时老师要班级里的同学按照某一种队形站位一样。&#xA;索引的用处 正因为索引是一种一种有序的数据组织形式，所以可以提高查询效率，也让排序行为变得简单。&#xA;索引的缺点 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。 索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。 索引到底是个什么 其实索引就只是一个硬盘上的文件而已，例如，在InnoDB引擎下，索引其实就是如下MySQL相关目录下的一个后缀名为.ibd的文件。&#xA;注：&#xA;如果使用MyISAM存储引擎，数据库文件类型就包括.frm (表结构描述)、.MYD (表数据)、.MYI (索引)&#xA;如果使用InnoDB存储引擎，数据库文件类型就包括.frm (表结构描述)、ibdata1 (共享表空间)、.ibd (索引)&#xA;索引在MySQL架构体系位置 MySQL宏观层面可以大致分层如图：&#xA;如上图可知，MySQL的索引其实是属于引擎层的数据结构。&#xA;MySQL支持的索引类型是和引擎息息相关的：&#xA;索引类型的比较 现在MySQL默认的存储引擎使用的是InnoDB，也是大多数公司的选择，而InnoDB的索引数据结构就是B+tree.每一个索引在InnoDB里面对应一棵B+树。&#xA;B+tree和B-tree(B-tree读B树不读B减树) B+tree是B-Tree的一个变种，B+tree只在叶子节点存储数据，而B-tree非叶子节点也存储数据，以下是实验链接：&#xA;B-tree B+tree&#xA;因此，B+tree 单个节点的数量更小，在相同的磁盘 IO 下能查询更多的节点。&#xA;另外 B+tree 叶子节点采用双向链表结构，适合MySQL中常见的基于范围的顺序检索场景，而 B-tree 无法做到这一点。&#xA;B+tree 索引与 Hash 表 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&#xA;但范围查询是MySQL数据库中常见的场景，而Hash表不适合做范围查询，Hash表更适合做等值查询。&#xA;B+tree索引结构图 数据页是什么 在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page），这部分非本文的重点内容，后续单开一篇来讲。&#xA;页（Pages）是mysql中磁盘和内存交换的基本单位，也是mysql管理存储空间的基本单位。&#xA;Buffer Pool 中存的就是一页一页的数据。再比如，当我们要查询的数据不在 Buffer Pool 中时，InnoDB 会将记录所在的页整个加载到 Buffer Pool 中去；同样的，当我们修改数据时，都需要将数据所在的数据页从磁盘读入到Buffer Pool中，然后在Buffer Pool中对其进行操作，操作完成后将 Buffer Pool 中的脏页刷入磁盘时，也是按照页为单位刷入磁盘的。同一个数据库实例的所有表空间都有相同的页大小，默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变源码中的页大小参数重新编译进行修改，不同的页大小最终也会导致区大小的不同。&#xA;当插入一行数据时，会将该数据页加载到Buffer Pool中，然后从空闲区域中拿出一部分空间分配给数据行区域，当空闲区域耗尽时，表示该数据页已经满了。</description>
    </item>
    <item>
      <title>分布式锁之电商防超卖的N&#43;1个坑</title>
      <link>https://blog.hanyu.me/tech/1/</link>
      <pubDate>Tue, 23 Mar 2021 22:40:49 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/1/</guid>
      <description>大家好，我是Damon。&#xA;今天和同事讨论库存防超卖问题，发现虽然只是简单的库存扣减场景，却隐藏着很多坑，一不小心就容易翻车，让我来填平这些坑。&#xA;单实例环境 一般电商体系防止库存超卖，主要有以下几种方式：&#xA;防止库存超卖，最先想到的可能就是「锁」，如果是一些单实例部署的库存服务，大部分情况下我们可以使用以下锁或并发工具类：&#xA;这三个任何一个都可以保证同一单位时间只有一个线程能够进行库存扣减，废话不多说，上码！&#xA;/** * 库存扣减（伪代码 ReentrantLock ) * @param stockRequestDTO * @return Boolean */ public Boolean stockHandle(StockRequestDTO stockRequestDTO) { // 日志打印...校验...前置处理等... int stock = stockMapper.getStock(stockRequestDTO.getGoodsId()); reentrantLock.lock(); try { int result = stock &amp;gt; 0 ? stockMapper.updateStock(stockRequestDTO.getGoodsId(), --stock) : 0; return result &amp;gt; 0 ? true : false; } catch (SQLException e) { // 异常日志打印及处理... return false; } finally { reentrantLock.unlock(); } } /** * 库存扣减（伪代码 synchronized ) * @param stockRequestDTO * @return Boolean */ public synchronized Boolean stockHandle(StockRequestDTO stockRequestDTO){ // 执行业务逻辑.</description>
    </item>
  </channel>
</rss>
